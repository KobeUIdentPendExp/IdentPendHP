<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>交互式控制系统仿真</title>
  <!-- 引入 Plotly 用于绘图 -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <!-- 引入 math.js 用于数学计算（可选） -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/10.6.4/math.js"></script>
  <style>
    .slider-container { margin: 10px 0; }
  </style>
</head>
<body>
  <h1>交互式控制系统仿真</h1>
  
  <!-- 内环参数滑块 -->
  <div class="slider-container">
    <label for="Kp">Kp (内环)：</label>
    <input type="range" id="Kp" min="0.1" max="10" step="0.1" value="1.0">
    <span id="Kp_val">1.0</span>
  </div>
  <div class="slider-container">
    <label for="Ki">Ki (内环)：</label>
    <input type="range" id="Ki" min="0.1" max="10" step="0.1" value="1.0">
    <span id="Ki_val">1.0</span>
  </div>
  
  <!-- 外环参数滑块 -->
  <div class="slider-container">
    <label for="Kp_theta">Kp (外环)：</label>
    <input type="range" id="Kp_theta" min="0.1" max="10" step="0.1" value="1.0">
    <span id="Kp_theta_val">1.0</span>
  </div>
  <div class="slider-container">
    <label for="Ki_theta">Ki (外环)：</label>
    <input type="range" id="Ki_theta" min="0" max="5" step="0.1" value="0.5">
    <span id="Ki_theta_val">0.5</span>
  </div>
  <div class="slider-container">
    <label for="Kd_theta">Kd (外环)：</label>
    <input type="range" id="Kd_theta" min="0" max="5" step="0.1" value="0.2">
    <span id="Kd_theta_val">0.2</span>
  </div>
  
  <!-- 绘图区 -->
  <div id="bodePlot" style="width: 600px; height: 400px;"></div>
  <div id="rlocusPlot" style="width: 600px; height: 400px; margin-top:20px;"></div>
  <div id="stepResponsePlot" style="width: 600px; height: 400px; margin-top:20px;"></div>
  
  <script>
    // 固定系统参数
    const L = 0.1;      // 电感 (H)
    const R = 1.0;      // 电阻 (Ohm)
    const k_T = 0.5;    // 转矩常数 (N·m/A)
    const J = 0.2;      // 转动惯量 (kg·m²)
    const B = 0.1;      // 摩擦系数 (N·m·s/rad)
    const tau_m = L / R;
    const K_m = 1 / R;
    
    // 获取滑块 DOM 元素
    const sliders = {
      Kp: document.getElementById("Kp"),
      Ki: document.getElementById("Ki"),
      Kp_theta: document.getElementById("Kp_theta"),
      Ki_theta: document.getElementById("Ki_theta"),
      Kd_theta: document.getElementById("Kd_theta")
    };
    const sliderVals = {
      Kp: document.getElementById("Kp_val"),
      Ki: document.getElementById("Ki_val"),
      Kp_theta: document.getElementById("Kp_theta_val"),
      Ki_theta: document.getElementById("Ki_theta_val"),
      Kd_theta: document.getElementById("Kd_theta_val")
    };

    // 更新显示的滑块数值
    function updateSliderDisplay() {
      for (let key in sliders) {
        sliderVals[key].innerText = sliders[key].value;
      }
    }

    // 简单计算一个传递函数在频域的响应（示例：仅针对内环传递函数）
    // 假设 G_inner(s) = K_m*(Kp*s + Ki) / (tau_m*s^2 + (1 + K_m*Kp)*s + K_m*Ki)
    // 为了生成 Bode 图，我们对一组频率（omega）计算 G_inner(j*omega)
    function computeBodeData(Kp, Ki) {
      const omega = math.range(0.01, 100, true).toArray();
      let mag = [];
      let phase = [];
      omega.forEach(w => {
        // s = j*w
        const s = math.complex(0, w);
        const num = math.add(math.multiply(Kp, s), Ki);
        const den = math.add(
          math.multiply(tau_m, math.pow(s, 2)),
          math.add(math.multiply(1 + K_m*Kp, s), K_m*Ki)
        );
        const G = math.divide(math.multiply(K_m, num), den);
        mag.push(20 * Math.log10(math.abs(G)));
        phase.push(math.arg(G) * 180 / Math.PI);
      });
      return { omega, mag, phase };
    }

    // 更新图形：Bode 图、根轨迹、阶跃响应
    function updatePlots() {
      updateSliderDisplay();
      const Kp = parseFloat(sliders.Kp.value);
      const Ki = parseFloat(sliders.Ki.value);
      // 外环参数在此示例中未用于计算（留作扩展），这里仅展示内环传递函数的 Bode 图
      
      // Bode 图数据
      const bodeData = computeBodeData(Kp, Ki);
      
      // 绘制 Bode 幅频响应曲线
      const bodeTrace = {
        x: bodeData.omega,
        y: bodeData.mag,
        type: 'scatter',
        mode: 'lines',
        name: 'Magnitude [dB]'
      };
      const bodeLayout = {
        title: 'Bode Plot (幅频响应)',
        xaxis: { type: 'log', title: 'Frequency (rad/s)' },
        yaxis: { title: 'Magnitude (dB)' }
      };
      Plotly.newPlot('bodePlot', [bodeTrace], bodeLayout);
      
      // 根轨迹和阶跃响应部分仅作示例占位（实际计算需要更复杂的实现）
      // 例如：你可以利用数值方法计算闭环系统极点，并绘制极点轨迹
      Plotly.newPlot('rlocusPlot', [{
        x: [ -1, -2, -3 ], y: [0, 0.5, -0.5],
        mode: 'markers',
        type: 'scatter'
      }], { title: 'Root Locus (示例数据)' });
      
      // 阶跃响应示例：这里使用简单的一阶系统响应模拟
      const t = math.range(0, 5, 0.05).toArray();
      const y = t.map(time => 1 - Math.exp(-time)); // 一阶系统阶跃响应
      Plotly.newPlot('stepResponsePlot', [{
        x: t, y: y,
        mode: 'lines',
        type: 'scatter'
      }], {
        title: 'Step Response (示例数据)',
        xaxis: { title: 'Time (s)' },
        yaxis: { title: 'Amplitude' }
      });
    }

    // 为每个滑块添加事件监听
    for (let key in sliders) {
      sliders[key].addEventListener('input', updatePlots);
    }
    
    // 初始绘制
    updatePlots();
  </script>
</body>
</html>
